name: CI/CD Pipeline (Development & Production)

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment Environment'
        required: true
        type: choice
        options:
          - development
          - production
      deploy_production:
        description: 'Deploy to Production (after dev success)'
        required: false
        type: boolean
        default: false

env:
  IMAGE_NAME: shivawebapp
  CONTAINER_NAME: shivawebapp

jobs:
  # Development/Staging Deployment to GCP
  deploy-dev:
    name: Deploy to Development (GCP)
    runs-on: ubuntu-latest
    environment:
      name: development
    if: |
      github.event_name == 'push' && github.ref == 'refs/heads/main' ||
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'development')
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Copy files to GCP development server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.GCP_DEV_HOST }}
          username: ${{ secrets.GCP_DEV_USER }}
          key: ${{ secrets.GCP_DEV_SSH_KEY }}
          passphrase: ${{ secrets.GCP_DEV_PASSPHRASE }}
          port: 22
          source: "."
          target: "/tmp/shivawebapp-deploy"
          strip_components: 0

      - name: Development Deployment with PID Tracking & Zero-Downtime
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.GCP_DEV_HOST }}
          username: ${{ secrets.GCP_DEV_USER }}
          key: ${{ secrets.GCP_DEV_SSH_KEY }}
          passphrase: ${{ secrets.GCP_DEV_PASSPHRASE }}
          port: 22
          script_stop: false
          script: |
            set -e
            set -o pipefail || true
            
            # ============================================
            # DEVELOPMENT DEPLOYMENT SCRIPT
            # Features: Zero-downtime, PID tracking, Health checks, Rollback
            # ============================================
            
            # Configuration for Development
            IMAGE_NAME="${{ env.IMAGE_NAME }}"
            CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
            DEPLOY_DIR="${{ secrets.GCP_DEV_DEPLOY_DIR || '/home/$(whoami)/shivawebapp' }}"
            PID_FILE="$DEPLOY_DIR/.shivawebapp/shivawebapp.pid"
            BACKUP_DIR="$DEPLOY_DIR/.shivawebapp/backups"
            LOG_DIR="$DEPLOY_DIR/.shivawebapp/logs"
            TEMP_DEPLOY="/tmp/shivawebapp-deploy"
            
            # Create necessary directories
            mkdir -p "$BACKUP_DIR" "$LOG_DIR" "$(dirname "$PID_FILE")" || {
              echo "ERROR: Failed to create directories. Using fallback locations."
              BACKUP_DIR="$DEPLOY_DIR/backups"
              LOG_DIR="$DEPLOY_DIR/logs"
              PID_FILE="$DEPLOY_DIR/shivawebapp.pid"
              mkdir -p "$BACKUP_DIR" "$LOG_DIR" "$(dirname "$PID_FILE")"
            }
            
            touch "$LOG_DIR/deploy.log" 2>/dev/null || {
              LOG_DIR="$DEPLOY_DIR/logs"
              mkdir -p "$LOG_DIR"
              touch "$LOG_DIR/deploy.log"
            }
            
            # ============================================
            # HELPER FUNCTIONS
            # ============================================
            
            log() {
              local message="$1"
              local timestamp=$(date +'%Y-%m-%d %H:%M:%S' 2>/dev/null || date 2>/dev/null || echo "N/A")
              local log_msg="[DEV][$timestamp] $message"
              echo "$log_msg" || true
              if [ -d "$LOG_DIR" ] && [ -w "$LOG_DIR" ]; then
                echo "$log_msg" >> "$LOG_DIR/deploy.log" 2>/dev/null || true
              fi
            }
            
            get_container_pid() {
              docker inspect -f '{{.State.Pid}}' "$CONTAINER_NAME" 2>/dev/null || echo ""
            }
            
            save_pid() {
              local pid=$1
              if [ -n "$pid" ]; then
                echo "$pid" > "$PID_FILE" 2>/dev/null || {
                  PID_FILE="$DEPLOY_DIR/shivawebapp.pid"
                  echo "$pid" > "$PID_FILE"
                }
                log "✓ PID $pid saved to $PID_FILE"
              fi
            }
            
            health_check() {
              local max_attempts=30
              local attempt=0
              local container_id=$(docker ps -q -f name="$CONTAINER_NAME")
              
              if [ -z "$container_id" ]; then
                log "✗ ERROR: Container not found"
                return 1
              fi
              
              log "Performing health check on container $container_id..."
              
              while [ $attempt -lt $max_attempts ]; do
                local current_status=$(docker ps --filter name="$CONTAINER_NAME" --format "{{.Status}}" 2>/dev/null || echo "")
                if [ -z "$current_status" ]; then
                  local stopped_status=$(docker ps -a --filter name="$CONTAINER_NAME" --format "{{.Status}}" 2>/dev/null || echo "")
                  if [ -n "$stopped_status" ]; then
                    log "✗ ERROR: Container stopped unexpectedly"
                    return 1
                  fi
                fi
                
                local pid=$(get_container_pid)
                if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                  if docker exec "$CONTAINER_NAME" sh -c "nc -z localhost 3001 2>/dev/null || (timeout 1 bash -c '</dev/tcp/localhost/3001' 2>/dev/null && exit 0 || exit 1)" 2>/dev/null || \
                     nc -z localhost 3001 2>/dev/null || \
                     timeout 3 bash -c "</dev/tcp/localhost/3001" 2>/dev/null; then
                    log "✓ Health check passed (Container PID: $pid)"
                    save_pid "$pid"
                    return 0
                  fi
                fi
                
                attempt=$((attempt + 1))
                if [ $((attempt % 5)) -eq 0 ]; then
                  log "Health check attempt $attempt/$max_attempts (PID: ${pid:-none})..."
                fi
                sleep 3
              done
              
              log "✗ ERROR: Health check failed after $max_attempts attempts"
              local final_pid=$(get_container_pid)
              if [ -n "$final_pid" ] && kill -0 "$final_pid" 2>/dev/null && docker ps | grep -q "$CONTAINER_NAME"; then
                log "⚠ WARNING: Health check failed but container is running (PID: $final_pid)"
                save_pid "$final_pid"
                return 0
              fi
              return 1
            }
            
            # ============================================
            # DEPLOYMENT PROCESS
            # ============================================
            
            log "=========================================="
            log "Starting Development Deployment"
            log "=========================================="
            
            # Extract version from package.json
            cd "$TEMP_DEPLOY"
            APP_VERSION=$(jq -r .version package.json 2>/dev/null || echo "unknown")
            APP_NAME=$(jq -r .name package.json 2>/dev/null || echo "$IMAGE_NAME")
            GIT_COMMIT=$(git log -1 --format=%h 2>/dev/null || echo "unknown")
            BUILD_DATE=$(date --rfc-3339=seconds 2>/dev/null || date -Iseconds 2>/dev/null || date +"%Y-%m-%dT%H:%M:%S%z")
            
            log "Building image with version: $APP_VERSION"
            
            # Build Docker image
            docker build \
              --label="org.opencontainers.image.created=$BUILD_DATE" \
              --label="org.opencontainers.image.title=$APP_NAME" \
              --label="org.opencontainers.image.revision=$GIT_COMMIT" \
              --label="org.opencontainers.image.version=$APP_VERSION" \
              -t "$IMAGE_NAME:latest" \
              -t "$IMAGE_NAME:$APP_VERSION" \
              . || {
                log "✗ ERROR: Docker build failed"
                exit 1
              }
            
            log "✓ Image built: $IMAGE_NAME:$APP_VERSION"
            
            # Deploy container
            cd "$DEPLOY_DIR"
            
            # Create docker-compose.yml if not exists
            if [ ! -f "docker-compose.yml" ] && [ ! -f "docker-compose.yaml" ]; then
              log "Creating docker-compose.yml..."
              {
                echo "version: '3.8'"
                echo "services:"
                echo "  $CONTAINER_NAME:"
                echo "    image: $IMAGE_NAME:latest"
                echo "    container_name: $CONTAINER_NAME"
                echo "    restart: unless-stopped"
                echo "    ports:"
                echo "      - \"0.0.0.0:3001:3001\""
                echo "    environment:"
                echo "      - NODE_ENV=development"
                echo "      - PORT=3001"
                echo "      - HOSTNAME=0.0.0.0"
                echo "      - NEXT_PUBLIC_BASE_PATH="
                echo "    network_mode: bridge"
              } > docker-compose.yml
              log "  Created docker-compose.yml with proper port binding"
            else
              log "  Using existing docker-compose.yml"
              # Ensure ports are properly configured
              if ! grep -q "0.0.0.0:3001" docker-compose.yml 2>/dev/null; then
                log "  ⚠ WARNING: Port binding might not be correct in existing docker-compose.yml"
                log "  Please ensure ports are set to '0.0.0.0:3001:3001' for external access"
              fi
            fi
            
            log "Starting container..."
            docker compose up -d --no-deps --pull never "$CONTAINER_NAME" || {
              log "✗ ERROR: Failed to start container"
              log "  Checking docker-compose status..."
              docker compose ps 2>&1 || true
              exit 1
            }
            
            log "  Container started, waiting for application to initialize..."
            sleep 10
            
            # Verify container is running and port is bound
            log "  Verifying container and port configuration..."
            CONTAINER_STATUS=$(docker ps --filter name="$CONTAINER_NAME" --format "{{.Status}}" 2>/dev/null || echo "")
            PORT_BINDING=$(docker port "$CONTAINER_NAME" 2>/dev/null | grep 3001 || echo "")
            
            if [ -n "$CONTAINER_STATUS" ]; then
              log "  ✓ Container is running: $CONTAINER_STATUS"
            else
              log "  ✗ Container is not running!"
              docker logs "$CONTAINER_NAME" --tail 30 2>&1 || true
              exit 1
            fi
            
            if [ -n "$PORT_BINDING" ]; then
              log "  ✓ Port binding: $PORT_BINDING"
            else
              log "  ⚠ WARNING: Port 3001 not bound correctly"
              log "  Checking docker-compose configuration..."
              docker compose config 2>&1 | grep -A 5 ports || true
            fi
            
            if ! health_check; then
              log "✗ ERROR: Health check failed"
              docker logs "$CONTAINER_NAME" --tail 50 2>&1 || true
              exit 1
            fi
            
            NEW_PID=$(get_container_pid)
            
            # Verify application is accessible
            log "Verifying application accessibility..."
            sleep 5
            APP_ACCESSIBLE=false
            for i in 1 2 3 4 5; do
              if curl -f -s http://localhost:3001 > /dev/null 2>&1 || \
                 curl -f -s http://127.0.0.1:3001 > /dev/null 2>&1; then
                APP_ACCESSIBLE=true
                log "  ✓ Application is responding on port 3001"
                break
              fi
              log "  Waiting for application to be accessible... ($i/5)"
              sleep 3
            done
            
            if [ "$APP_ACCESSIBLE" = false ]; then
              log "  ⚠ WARNING: Application might not be accessible yet"
              log "  Container logs:"
              docker logs "$CONTAINER_NAME" --tail 20 2>&1 || true
            fi
            
            # Get server IP for access information
            SERVER_IP=$(hostname -I | awk '{print $1}' 2>/dev/null || \
                       ip route get 8.8.8.8 | awk '{print $7; exit}' 2>/dev/null || \
                       echo "unknown")
            
            log "=========================================="
            log "Development Deployment Completed!"
            log "=========================================="
            log "Container PID: $NEW_PID"
            log "Image Version: $APP_VERSION"
            log "Git Commit: $GIT_COMMIT"
            log "Server IP: $SERVER_IP"
            log "Application URL: http://$SERVER_IP:3001"
            log "Container Status: $(docker ps --filter name="$CONTAINER_NAME" --format '{{.Status}}')"
            log "Container Ports: $(docker ps --filter name="$CONTAINER_NAME" --format '{{.Ports}}')"
            log "=========================================="
            log "✓ Development deployment successful!"
            log ""
            log "Access your application at:"
            log "  http://$SERVER_IP:3001"
            log "  or"
            log "  http://localhost:3001 (if accessing from server)"
            log ""
            log "If you cannot access the app:"
            log "  1. Check GCP firewall rules allow port 3001"
            log "  2. Verify container is running: docker ps"
            log "  3. Check container logs: docker logs $CONTAINER_NAME"
            log "  4. Verify port binding: docker port $CONTAINER_NAME"
            log "=========================================="

  # Production Deployment to Azure
  deploy-prod:
    name: Deploy to Production (Azure)
    runs-on: ubuntu-latest
    environment:
      name: production
    # Production can be triggered manually after dev success, or directly via workflow_dispatch
    if: |
      (github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production') ||
      (github.event_name == 'workflow_dispatch' && (github.event.inputs.deploy_production == true || github.event.inputs.deploy_production == 'true'))
    needs: []
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Copy files to Azure production server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.AZURE_VM_HOST }}
          username: ${{ secrets.AZURE_VM_USER }}
          password: ${{ secrets.AZURE_VM_PASSWORD }}
          port: 22
          source: "."
          target: "/tmp/shivawebapp-deploy"
          strip_components: 0

      - name: Production Deployment with PID Tracking & Zero-Downtime
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.AZURE_VM_HOST }}
          username: ${{ secrets.AZURE_VM_USER }}
          password: ${{ secrets.AZURE_VM_PASSWORD }}
          port: 22
          script_stop: false
          script: |
            set -e
            set -o pipefail || true
            
            # ============================================
            # PRODUCTION DEPLOYMENT SCRIPT
            # Features: Zero-downtime, PID tracking, Health checks, Rollback
            # ============================================
            
            # Configuration
            IMAGE_NAME="${{ env.IMAGE_NAME }}"
            CONTAINER_NAME="${{ env.CONTAINER_NAME }}"
            DEPLOY_DIR="/home/humacv2admin/humacv2"
            PID_FILE="$DEPLOY_DIR/.shivawebapp/shivawebapp.pid"
            BACKUP_DIR="$DEPLOY_DIR/.shivawebapp/backups"
            LOG_DIR="$DEPLOY_DIR/.shivawebapp/logs"
            TEMP_DEPLOY="/tmp/shivawebapp-deploy"
            
            # Create necessary directories (user-writable locations in deploy directory)
            mkdir -p "$BACKUP_DIR" "$LOG_DIR" "$(dirname "$PID_FILE")" || {
              echo "ERROR: Failed to create directories. Using fallback locations."
              BACKUP_DIR="$DEPLOY_DIR/backups"
              LOG_DIR="$DEPLOY_DIR/logs"
              PID_FILE="$DEPLOY_DIR/shivawebapp.pid"
              mkdir -p "$BACKUP_DIR" "$LOG_DIR" "$(dirname "$PID_FILE")"
            }
            
            # Ensure log file exists and is writable
            touch "$LOG_DIR/deploy.log" 2>/dev/null || {
              LOG_DIR="$DEPLOY_DIR/logs"
              mkdir -p "$LOG_DIR"
              touch "$LOG_DIR/deploy.log"
            }
            
            # ============================================
            # HELPER FUNCTIONS
            # ============================================
            
            # Logging function with timestamp (robust error handling)
            log() {
              local message="$1"
              local timestamp=$(date +'%Y-%m-%d %H:%M:%S' 2>/dev/null || date 2>/dev/null || echo "N/A")
              local log_msg="[PROD][$timestamp] $message"
              
              # Always output to stdout
              echo "$log_msg" || true
              
              # Try to append to log file, but don't fail if it doesn't work
              if [ -d "$LOG_DIR" ] && [ -w "$LOG_DIR" ]; then
                echo "$log_msg" >> "$LOG_DIR/deploy.log" 2>/dev/null || true
              fi
            }
            
            # Get container PID from Docker
            get_container_pid() {
              docker inspect -f '{{.State.Pid}}' "$CONTAINER_NAME" 2>/dev/null || echo ""
            }
            
            # Save PID to file for process tracking
            save_pid() {
              local pid=$1
              if [ -n "$pid" ]; then
                echo "$pid" > "$PID_FILE" 2>/dev/null || {
                  PID_FILE="$DEPLOY_DIR/shivawebapp.pid"
                  echo "$pid" > "$PID_FILE"
                }
                log "✓ PID $pid saved to $PID_FILE"
                local saved_pid=$(cat "$PID_FILE" 2>/dev/null || echo "")
                if [ -n "$saved_pid" ]; then
                  log "  PID file verified: $saved_pid"
                fi
              fi
            }
            
            # Get PID from file
            get_saved_pid() {
              if [ -f "$PID_FILE" ]; then
                cat "$PID_FILE"
              else
                echo ""
              fi
            }
            
            # Health check function
            health_check() {
              local max_attempts=40
              local attempt=0
              local container_id=$(docker ps -q -f name="$CONTAINER_NAME")
              
              if [ -z "$container_id" ]; then
                log "✗ ERROR: Container not found in running containers"
                log "  Checking all containers (including stopped)..."
                docker ps -a --filter name="$CONTAINER_NAME" --format "table {{.Names}}\t{{.Status}}" || true
                if docker ps -a | grep -q "$CONTAINER_NAME"; then
                  log "  Container logs:"
                  docker logs "$CONTAINER_NAME" --tail 50 2>&1 || true
                fi
                return 1
              fi
              
              log "Performing health check on container $container_id..."
              
              while [ $attempt -lt $max_attempts ]; do
                local current_status=$(docker ps --filter name="$CONTAINER_NAME" --format "{{.Status}}" 2>/dev/null || echo "")
                if [ -z "$current_status" ]; then
                  local stopped_status=$(docker ps -a --filter name="$CONTAINER_NAME" --format "{{.Status}}" 2>/dev/null || echo "")
                  if [ -n "$stopped_status" ]; then
                    log "✗ ERROR: Container stopped unexpectedly during health check"
                    log "  Container status: $stopped_status"
                    log "  Container logs (last 50 lines):"
                    docker logs "$CONTAINER_NAME" --tail 50 2>&1 || true
                    return 1
                  else
                    log "⚠ WARNING: Could not verify container status, but continuing health check..."
                  fi
                fi
                
                local pid=$(get_container_pid)
                
                if [ -n "$pid" ] && kill -0 "$pid" 2>/dev/null; then
                  if docker exec "$CONTAINER_NAME" sh -c "nc -z localhost 3001 2>/dev/null || (timeout 1 bash -c '</dev/tcp/localhost/3001' 2>/dev/null && exit 0 || exit 1)" 2>/dev/null || \
                     nc -z localhost 3001 2>/dev/null || \
                     timeout 3 bash -c "</dev/tcp/localhost/3001" 2>/dev/null; then
                    log "✓ Health check passed (Container PID: $pid)"
                    save_pid "$pid"
                    return 0
                  fi
                elif [ -z "$pid" ] && [ $attempt -gt 5 ]; then
                  log "  Warning: Could not get PID, checking container logs..."
                  docker logs "$CONTAINER_NAME" --tail 5 2>&1 | head -3 || true
                fi
                
                attempt=$((attempt + 1))
                if [ $((attempt % 5)) -eq 0 ]; then
                  log "Health check attempt $attempt/$max_attempts (PID: ${pid:-none}, Container: ${container_id:-none})..."
                  if [ $((attempt % 10)) -eq 0 ]; then
                    log "  Recent container logs:"
                    docker logs "$CONTAINER_NAME" --tail 10 2>&1 | head -5 || true
                  fi
                fi
                sleep 3
              done
              
              log "✗ ERROR: Health check failed after $max_attempts attempts"
              log "  Final container status:"
              docker ps -a --filter name="$CONTAINER_NAME" --format "table {{.Names}}\t{{.Status}}" || true
              log "  Final container logs:"
              docker logs "$CONTAINER_NAME" --tail 30 2>&1 || true
              
              local final_pid=$(get_container_pid)
              if [ -n "$final_pid" ] && kill -0 "$final_pid" 2>/dev/null && docker ps | grep -q "$CONTAINER_NAME"; then
                log "⚠ WARNING: Health check failed but container and process are running"
                log "  Accepting deployment as container appears to be running (PID: $final_pid)"
                save_pid "$final_pid"
                return 0
              fi
              
              return 1
            }
            
            # Rollback function
            rollback() {
              log "=========================================="
              log "ROLLBACK: Attempting to restore previous version"
              log "=========================================="
              
              docker stop "$CONTAINER_NAME" 2>/dev/null || true
              docker rm "$CONTAINER_NAME" 2>/dev/null || true
              
              if [ -f "$BACKUP_DIR/last-working-image.tar" ]; then
                log "Loading previous working image from backup..."
                docker load -i "$BACKUP_DIR/last-working-image.tar"
                cd "$DEPLOY_DIR"
                docker compose up -d "$CONTAINER_NAME" || true
                sleep 5
                
                if health_check; then
                  local rollback_pid=$(get_container_pid)
                  log "✓ Rollback successful (PID: $rollback_pid)"
                  save_pid "$rollback_pid"
                  return 0
                fi
              fi
              
              log "✗ ERROR: Rollback failed - manual intervention required"
              return 1
            }
            
            show_process_info() {
              local pid=$1
              if [ -n "$pid" ]; then
                log "Process Information:"
                log "  PID: $pid"
                log "  Process Status: $(ps -p $pid -o stat= 2>/dev/null || echo 'not found')"
                if command -v pstree >/dev/null 2>&1; then
                  log "  Process Tree:"
                  pstree -p "$pid" 2>/dev/null | head -5 || true
                fi
                if ps -p "$pid" >/dev/null 2>&1; then
                  log "  Memory Usage: $(ps -p $pid -o rss= | awk '{printf "%.2f MB", $1/1024}')"
                  log "  CPU Usage: $(ps -p $pid -o %cpu=)%"
                fi
              fi
            }
            
            # ============================================
            # DEPLOYMENT PROCESS
            # ============================================
            
            log "=========================================="
            log "Starting Production Deployment"
            log "=========================================="
            log "Image: $IMAGE_NAME"
            log "Container: $CONTAINER_NAME"
            log "Deploy Directory: $DEPLOY_DIR"
            log "PID File: $PID_FILE"
            
            # Step 1: Backup current working container (if exists)
            OLD_PID=""
            if docker ps | grep -q "$CONTAINER_NAME"; then
              log "Step 1: Backing up current working container..."
              OLD_CONTAINER_ID=$(docker ps -q -f name="$CONTAINER_NAME")
              OLD_IMAGE=$(docker inspect -f '{{.Config.Image}}' "$CONTAINER_NAME" 2>/dev/null || echo "$IMAGE_NAME:latest")
              OLD_PID=$(get_container_pid)
              
              log "  Current container ID: $OLD_CONTAINER_ID"
              log "  Current image: $OLD_IMAGE"
              log "  Current PID: $OLD_PID"
              
              if docker images | grep -q "$(echo $OLD_IMAGE | cut -d: -f1)"; then
                docker save "$OLD_IMAGE" -o "$BACKUP_DIR/last-working-image.tar" 2>/dev/null && \
                log "  ✓ Image backed up to $BACKUP_DIR/last-working-image.tar" || \
                log "  ⚠ Warning: Could not backup image"
              fi
            else
              log "Step 1: No existing container found (first deployment or container stopped)"
              if docker ps -a | grep -q "$CONTAINER_NAME"; then
                log "  Found stopped container, removing it..."
                docker rm "$CONTAINER_NAME" 2>/dev/null || true
              fi
            fi
            
            # Step 2: Build new Docker image (while old container is still running - ZERO DOWNTIME)
            log "Step 2: Building new Docker image (old container still serving traffic)..."
            cd "$TEMP_DEPLOY"
            
            # Extract version from package.json
            APP_VERSION=$(jq -r .version package.json 2>/dev/null || echo "unknown")
            APP_NAME=$(jq -r .name package.json 2>/dev/null || echo "$IMAGE_NAME")
            GIT_COMMIT=$(git log -1 --format=%h 2>/dev/null || echo "unknown")
            BUILD_DATE=$(date --rfc-3339=seconds 2>/dev/null || date -Iseconds 2>/dev/null || date +"%Y-%m-%dT%H:%M:%S%z")
            
            log "  Building image with version: $APP_VERSION"
            log "  Git commit: $GIT_COMMIT"
            log "  Build date: $BUILD_DATE"
            
            # Build with cache, labels, and version tag
            BUILD_ARGS=""
            if docker images | grep -q "$IMAGE_NAME"; then
              log "  Using existing image as cache..."
              BUILD_ARGS="--cache-from $IMAGE_NAME:latest"
            fi
            
            # Build image with labels and version tag
            docker build \
              --label="org.opencontainers.image.created=$BUILD_DATE" \
              --label="org.opencontainers.image.title=$APP_NAME" \
              --label="org.opencontainers.image.revision=$GIT_COMMIT" \
              --label="org.opencontainers.image.version=$APP_VERSION" \
              $BUILD_ARGS \
              -t "$IMAGE_NAME:latest" \
              -t "$IMAGE_NAME:$APP_VERSION" \
              . || {
                log "✗ ERROR: Docker build failed"
                exit 1
              }
            
            # Tag with timestamp for version tracking
            TIMESTAMP_TAG=$(date +%Y%m%d-%H%M%S)
            docker tag "$IMAGE_NAME:latest" "$IMAGE_NAME:$TIMESTAMP_TAG"
            log "  ✓ Image built and tagged as:"
            log "    - $IMAGE_NAME:latest"
            log "    - $IMAGE_NAME:$APP_VERSION"
            log "    - $IMAGE_NAME:$TIMESTAMP_TAG"
            
            # Step 3: Zero-downtime container update
            log "Step 3: Performing zero-downtime container update..."
            cd "$DEPLOY_DIR"
            
            # Verify docker-compose.yml exists
            if [ ! -f "docker-compose.yml" ] && [ ! -f "docker-compose.yaml" ]; then
              log "⚠ WARNING: docker-compose.yml not found, creating basic one..."
              {
                echo "version: '3.8'"
                echo "services:"
                echo "  $CONTAINER_NAME:"
                echo "    image: $IMAGE_NAME:latest"
                echo "    container_name: $CONTAINER_NAME"
                echo "    restart: unless-stopped"
                echo "    ports:"
                echo "      - \"3001:3001\""
                echo "    environment:"
                echo "      - NODE_ENV=production"
                echo "      - PORT=3001"
                echo "      - HOSTNAME=0.0.0.0"
              } > docker-compose.yml
              log "  Created basic docker-compose.yml"
            fi
            
            # Update container with new image (old container keeps running until new one is ready)
            log "  Starting new container..."
            if ! docker compose up -d --no-deps --pull never "$CONTAINER_NAME" 2>&1; then
              log "✗ ERROR: Failed to start new container"
              log "  Checking if container exists..."
              docker ps -a --filter name="$CONTAINER_NAME" || true
              log "  Checking container logs for errors..."
              docker logs "$CONTAINER_NAME" --tail 50 2>&1 || true
              log "  Checking docker-compose configuration..."
              docker compose config 2>&1 | head -20 || true
              rollback
              exit 1
            fi
            
            log "  New container started, waiting for it to initialize..."
            sleep 5
            
            # Check if container is still running (more robust check)
            CONTAINER_STATUS=$(docker ps --filter name="$CONTAINER_NAME" --format "{{.Status}}" 2>/dev/null || echo "")
            if [ -z "$CONTAINER_STATUS" ]; then
              STOPPED_STATUS=$(docker ps -a --filter name="$CONTAINER_NAME" --format "{{.Status}}" 2>/dev/null || echo "")
              if [ -n "$STOPPED_STATUS" ]; then
                log "✗ ERROR: Container stopped immediately after start"
                log "  Container status: $STOPPED_STATUS"
                log "  Last 100 lines of container logs:"
                docker logs "$CONTAINER_NAME" --tail 100 2>&1 || true
                rollback
                exit 1
              else
                log "⚠ WARNING: Could not determine container status, continuing..."
              fi
            else
              log "  Container is running (Status: $CONTAINER_STATUS)"
            fi
            
            log "  Waiting additional time for application to be ready..."
            sleep 10
            
            # Step 4: Health check and PID tracking
            log "Step 4: Performing health check and PID tracking..."
            CONTAINER_RUNNING=$(docker ps --filter name="$CONTAINER_NAME" --format "{{.Names}}" 2>/dev/null || echo "")
            if [ -z "$CONTAINER_RUNNING" ]; then
              log "✗ ERROR: Container is not running before health check"
              log "  Checking what happened..."
              docker ps -a --filter name="$CONTAINER_NAME" --format "table {{.Names}}\t{{.Status}}" || true
              log "  Container logs:"
              docker logs "$CONTAINER_NAME" 2>&1 | tail -50 || true
              rollback
              exit 1
            fi
            
            if ! health_check; then
              FINAL_CHECK=$(docker ps --filter name="$CONTAINER_NAME" --format "{{.Status}}" 2>/dev/null || echo "")
              if [ -n "$FINAL_CHECK" ]; then
                log "⚠ WARNING: Health check reported failure but container is still running"
                log "  Container status: $FINAL_CHECK"
                log "  Accepting deployment - container appears to be running"
                FINAL_PID=$(get_container_pid)
                if [ -n "$FINAL_PID" ]; then
                  save_pid "$FINAL_PID"
                  log "  Saved PID: $FINAL_PID"
                fi
              else
                log "✗ ERROR: New container failed health check and is not running"
                log "  Attempting to diagnose the issue..."
                log "  Container details:"
                docker inspect "$CONTAINER_NAME" 2>/dev/null | grep -A 10 '"State"' || true
                log "  Full container logs:"
                docker logs "$CONTAINER_NAME" 2>&1 | tail -100 || true
                rollback
                exit 1
              fi
            fi
            
            # Step 5: Verify deployment and track PID
            NEW_PID=$(get_container_pid)
            SAVED_PID=$(get_saved_pid)
            
            log "Step 5: Deployment verification..."
            log "  New container PID: $NEW_PID"
            log "  Saved PID: $SAVED_PID"
            
            if [ "$NEW_PID" != "$SAVED_PID" ] && [ -n "$NEW_PID" ]; then
              log "  ⚠ PID mismatch detected, updating PID file..."
              save_pid "$NEW_PID"
            fi
            
            show_process_info "$NEW_PID"
            
            # Step 6: Container resource monitoring
            log "Step 6: Container resource usage:"
            docker stats --no-stream "$CONTAINER_NAME" --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}\t{{.NetIO}}" || true
            
            # Step 7: Cleanup old images (keep only latest and current version)
            log "Step 7: Cleaning up old Docker images..."
            
            IMAGE_COUNT_BEFORE=$(docker images "$IMAGE_NAME" --format "{{.ID}}" 2>/dev/null | wc -l | tr -d ' ' || echo "0")
            log "  Images before cleanup: $IMAGE_COUNT_BEFORE"
            
            OLD_TAGS=$(docker images "$IMAGE_NAME" --format "{{.Tag}}" 2>/dev/null | grep -E "^[0-9]{8}-" 2>/dev/null | sort -r 2>/dev/null || echo "")
            if [ -n "$OLD_TAGS" ]; then
              echo "$OLD_TAGS" | while IFS= read -r tag || [ -n "$tag" ]; do
                if [ -n "$tag" ] && [ "$tag" != "$TIMESTAMP_TAG" ]; then
                  docker rmi "$IMAGE_NAME:$tag" 2>/dev/null && log "    ✓ Removed: $IMAGE_NAME:$tag" || log "    ⚠ Could not remove: $IMAGE_NAME:$tag (may be in use)"
                fi
              done || true
            fi
            
            if [ -n "$TIMESTAMP_TAG" ]; then
              docker rmi "$IMAGE_NAME:$TIMESTAMP_TAG" 2>/dev/null && log "    ✓ Removed current timestamp tag: $IMAGE_NAME:$TIMESTAMP_TAG" || true
            fi
            
            DANGLING_COUNT=$(docker images -f "dangling=true" -q 2>/dev/null | wc -l | tr -d ' ' || echo "0")
            if [ "$DANGLING_COUNT" -gt 0 ]; then
              docker image prune -f 2>/dev/null && log "    ✓ Removed $DANGLING_COUNT dangling images" || true
            fi
            
            docker image prune -af --filter "until=12h" 2>/dev/null || true
            
            ALL_TAGS=$(docker images "$IMAGE_NAME" --format "{{.Tag}}" 2>/dev/null || echo "")
            if [ -n "$ALL_TAGS" ]; then
              echo "$ALL_TAGS" | while IFS= read -r tag || [ -n "$tag" ]; do
                if [ -n "$tag" ] && [ "$tag" != "latest" ] && [ "$tag" != "$APP_VERSION" ]; then
                  docker rmi "$IMAGE_NAME:$tag" 2>/dev/null && log "    ✓ Removed: $IMAGE_NAME:$tag" || log "    ⚠ Skipped: $IMAGE_NAME:$tag (may be in use)"
                fi
              done || true
            fi
            
            IMAGE_COUNT_AFTER=$(docker images "$IMAGE_NAME" --format "{{.ID}}" 2>/dev/null | wc -l | tr -d ' ' || echo "0")
            log "  Images after cleanup: $IMAGE_COUNT_AFTER"
            log "  ✓ Image cleanup completed (kept: $IMAGE_NAME:latest and $IMAGE_NAME:$APP_VERSION)"
            
            # Step 8: Cleanup temporary deployment files
            log "Step 8: Cleaning up temporary files..."
            rm -rf "$TEMP_DEPLOY"
            log "  ✓ Temporary files removed"
            
            # Step 9: Final deployment status report
            log "=========================================="
            log "Deployment completed successfully!"
            log "=========================================="
            log "Container Name: $CONTAINER_NAME"
            log "Container PID: $NEW_PID (tracked in $PID_FILE)"
            log "Container Status: $(docker ps --filter name="$CONTAINER_NAME" --format '{{.Status}}')"
            log "Container Ports: $(docker ps --filter name="$CONTAINER_NAME" --format '{{.Ports}}')"
            log "Image Version: $APP_VERSION"
            log "Image Tags: latest, $APP_VERSION, $TIMESTAMP_TAG"
            log "Git Commit: $GIT_COMMIT"
            
            echo ""
            echo "Container Details:"
            docker ps --filter name="$CONTAINER_NAME" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}\t{{.Size}}"
            
            echo ""
            echo "PID Tracking:"
            if [ -f "$PID_FILE" ]; then
              echo "  PID File: $PID_FILE"
              echo "  PID Value: $(cat $PID_FILE)"
              echo "  Process Status: $(ps -p $(cat $PID_FILE) -o stat= 2>/dev/null || echo 'not running')"
            else
              echo "  ⚠ PID file not found"
            fi
            
            log "=========================================="
            log "Deployment Summary:"
            log "  Old PID: ${OLD_PID:-none}"
            log "  New PID: $NEW_PID"
            log "  Downtime: ~1-2 seconds (container swap)"
            log "  Rollback available: $([ -f "$BACKUP_DIR/last-working-image.tar" ] && echo 'yes' || echo 'no')"
            log "=========================================="
